// Adafruit_NeoMatrix example for single NeoPixel Shield.
// Scrolls 'Howdy' across the matrix in a portrait (vertical) orientation.

#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

#ifndef PSTR
#define PSTR // Make Arduino Due happy
#endif

#define BUTTON_PIN_1   2 
#define BUTTON_PIN_2   5
#define PIN    6 

// MATRIX DECLARATION:
// Parameter 1 = width of NeoPixel matrix
// Parameter 2 = height of matrix
// Parameter 3 = pin number (most are valid)
// Parameter 4 = matrix layout flags, add together as needed:

Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, PIN,  
  NEO_MATRIX_BOTTOM + NEO_MATRIX_LEFT 
  + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, 
  NEO_GRB + NEO_KHZ800);

int j;
const uint16_t colors[] = {
  matrix.Color(255, 0, 0), matrix.Color(0, 255, 0), matrix.Color(0, 0, 255) };

void setup() {
  Serial.begin(9600);
  matrix.begin();
  matrix.setTextWrap(false);
  matrix.setBrightness(40);
  matrix.setTextColor(colors[0]);
  pinMode(BUTTON_PIN_1, INPUT_PULLUP);
  pinMode(BUTTON_PIN_2, INPUT_PULLUP);
  matrix.show(); // Initialize all pixels to 'off'
}

int x = matrix.width();
int pass = 0;
int c;
int button_1;
int button_2;
bool oldButton = LOW;

void loop() {

Serial.println("Start over");

// Clear the matrix! All pixels off!
c = matrix.Color(0, 0, 0);
for (int i = 0; i<256; i++) { 
  matrix.setPixelColor(i,c);
  }
matrix.show();

// Right Turn Signal (Button Pin 1)
// Check if the state of the button has been changed (has it changed from LOW to HIGH?)
if (digitalRead(BUTTON_PIN_1) == HIGH && oldButton == LOW) { // If button is now "HIGH" (that means you initially pressed the button down)
  Serial.println("Blue");
  delay(100); // Give the user a second to hold on/let go
  button_1 = digitalRead(BUTTON_PIN_1); // Check the button now. 
    if (button_1 = LOW); // Button = LOW. This means you let go of the button, so the button has officially been pressed!
    Serial.println("Right button press");
    button_1 = 1;
    while (button_1 = 1) {
     rightSignal(button_1); // Start the turn signal
      
        if (digitalRead(BUTTON_PIN_1) == HIGH) { // If you press the button WHILE the turn signal is on, break the while loop
             Serial.print("holding1"); 
             delay(1000); // Slightly inconvenient but a VERY IMPORTANT DELAY FOR THE WELLNESS OF THE CODE
             break; // This will take us back up to the top of the loop and clear the pixels
        }
    }
}

// Left Turn Signal (Button Pin 2)
if (digitalRead(BUTTON_PIN_2) == HIGH && oldButton == LOW) { 
  Serial.println("yellow");
  delay(100); 
  button_2 = digitalRead(BUTTON_PIN_2); 
    if (button_2 = LOW);
    Serial.print("Button press2");
    button_2 = 2;
    while (button_2 = 2) {
      leftSignal(button_2);
      
        if (digitalRead(BUTTON_PIN_2) == HIGH) { 
             Serial.print("holding2"); 
             delay(1000);
             break;
        }
    }
}
}

void rightSignal(int button_1) {
  for(j=0; j<10; j++) { // This j is a counter. Not sure how necessary it is but I don't want to mess with it.
      Serial.println("Looping Right");
      matrix.fillScreen(0); // ".fillScreen" can fill the screen with any color. Here, we chose 0, so this clears the matrix.
      matrix.setCursor(x-32, 0);
      matrix.print(F(">>>>>>>>"));
      // FIGURE OUT HOW TO REVERSE THE DIRECTION
        if(--x < -6) {
         x = matrix.width();
        }
      delay(50);
      matrix.show();
        if (digitalRead(BUTTON_PIN_1) == HIGH) {
         Serial.print("stop 1");
         break;
        }
   }
}

void leftSignal(int button_2) {
  for(j=0; j<10; j++) { 
      Serial.println("Looping Left");
      matrix.fillScreen(0); 
      matrix.setCursor(x, 0);
      matrix.print(F("<<<<<<<<"));
        if(--x < -6) {
         x = matrix.width();
        }
      delay(50);
      matrix.show();
        if (digitalRead(BUTTON_PIN_2) == HIGH) {
         Serial.print("stop 2");
         break;
        }
   }

}

