// Bike Turn Signals!
// Scrolls turn signal arrows, ">" or "<" across the matrix in a portrait (vertical) orientation.
// Signals can only be turned off by their corresponding button. For example, if you press the blue button to turn on the right turn signal, 
// pressing the yellow button won't do anything. You can only turn it off using the blue button, and would only THEN be able to turn on the 
// left turn signal by pressing the yellow button. 

#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

#ifndef PSTR
#define PSTR // Make Arduino Due happy
#endif

#define BUTTON_PIN_1  2 
#define BUTTON_PIN_2  5
#define PIN  6 

// MATRIX DECLARATION:
// Parameter 1 = width of NeoPixel matrix
// Parameter 2 = height of matrix
// Parameter 3 = pin number (most are valid)
// Parameter 4 = matrix layout flags, add together as needed:

Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, PIN,  
 NEO_MATRIX_BOTTOM + NEO_MATRIX_LEFT 
 + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, 
  NEO_GRB + NEO_KHZ800);

int j, y;
int x = matrix.width();
int pass = 0;
int c;
int button_1;
int button_2;
bool oldButton = LOW;
const uint16_t colors[] = { matrix.Color(255, 0, 0), matrix.Color(0, 255, 0), matrix.Color(0, 0, 255) };

void setup() {
  Serial.begin(9600);
  matrix.begin();
  matrix.setTextWrap(false);
  matrix.setBrightness(40);
  matrix.setTextColor(colors[0]);
  pinMode(BUTTON_PIN_1, INPUT_PULLUP);
  pinMode(BUTTON_PIN_2, INPUT_PULLUP);
  matrix.show(); // Initialize all pixels to 'off'
}


void loop() {
 //Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(8, 8, PIN,  
 //NEO_MATRIX_BOTTOM + NEO_MATRIX_LEFT 
 // + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, 
 //NEO_GRB + NEO_KHZ800);
 
Serial.println("Start over");

// Clear the matrix! All pixels off!
c = matrix.Color(0, 0, 0);
for (int i = 0; i<256; i++) { 
  matrix.setPixelColor(i,c);
  }
matrix.show();

// Right Turn Signal (Button Pin 1)
// Check if the state of the button has been changed (has it changed from LOW to HIGH?)
if (digitalRead(BUTTON_PIN_1) == HIGH && oldButton == LOW) { // If button is now "HIGH" (that means you initially pressed the button down)
  Serial.println("Blue");
  delay(100); // Give the user a second to hold on/let go
  button_1 = digitalRead(BUTTON_PIN_1); // Check the button now. 
    if (button_1 = LOW); // Button = LOW. This means you let go of the button, so the button has officially been pressed!
    Serial.println("Right button press");
    button_1 = 1;
    while (button_1 = 1) {
     rightSignal(button_1); // Start the turn signal
      
        if (digitalRead(BUTTON_PIN_1) == HIGH) { // If you press the button WHILE the turn signal is on, break the while loop
             Serial.print("holding1"); 
             delay(1000); // Slightly inconvenient but a VERY IMPORTANT DELAY FOR THE WELLNESS OF THE CODE
             break; // This will take us back up to the top of the loop and clear the pixels
        }   
    }
}


// Left Turn Signal (Button Pin 2)
if (digitalRead(BUTTON_PIN_2) == HIGH && oldButton == LOW) { 
  Serial.println("yellow");
  delay(100); 
  button_2 = digitalRead(BUTTON_PIN_2); 
    if (button_2 = LOW);
    Serial.print("Button press2");
    button_2 = 2;
    while (button_2 = 2) {
      leftSignal(button_2);
      
        if (digitalRead(BUTTON_PIN_2) == HIGH) { 
             Serial.print("holding2"); 
             delay(1000);
             break;
        }
    }
}
}

void rightSignal(int button_1) {
  for(j=0; j<10; j++) { // This j is a counter. Not sure how necessary it is but I don't want to mess with it.
      Serial.println("Looping right, Blue");

      matrix.fillScreen(0); 
      matrix.setCursor(x-16,0); // Has the text start in the middle
      
      matrix.print(F(">>>"));
       if (++x > 44) {
        Serial.print("x=");
        Serial.println(x);
        // ++ x< 34 MESSES IT UP (with setCursor at x-16)
       x = matrix.width(); // DON'T MESS WE NEED THIS
       Serial.println(matrix.width());
       matrix.fillScreen(0);
        delay(10);
       if(++pass >= 3) 
          pass = 0;
         matrix.setTextColor(colors[pass]); 
         Serial.println("New color!");
        }
      delay(50);
      matrix.show();
      
      /* // IT'S REVERSING HOLY SHIT
      matrix.fillScreen(0); 
      matrix.setCursor(x-12,0);
      matrix.print(F(">>>"));
      
       if(++x < -2) {
       x = -16;
       matrix.fillScreen(0);
        delay(10);
       if(++pass >= 3) pass = 0;
         matrix.setTextColor(colors[pass]); 
        }
      delay(500);
      matrix.show();
      
      /*
      matrix.fillScreen(0); // ".fillScreen" can fill the screen with any color. Here, we chose 0, so this clears the matrix.
      matrix.setCursor(x,0);
      matrix.print(F(">>>>>>>>"));
      // FIGURE OUT HOW TO REVERSE THE DIRECTION
        if(--x < -36) {
         x = matrix.width();
        }
      delay(50);
      matrix.show();
      /*
       * 
       */
        if (digitalRead(BUTTON_PIN_1) == HIGH) {
         Serial.print("stop 1");
         break;
        }
 }
}

void leftSignal(int button_2) {
  for(j=0; j<10; j++) { 
      Serial.println("Looping Left, Yellow");

      matrix.fillScreen(0); 
      matrix.setCursor(x-32,0);
      matrix.print(F("<<<"));
      
       if(--x < 20) { // (x < A), 32-A is how many spaces the LEDs will move (????)
       x = matrix.width();
       Serial.println(matrix.width());
       matrix.fillScreen(0);
        delay(10);
       if(++pass >= 3) pass = 0;
         matrix.setTextColor(colors[pass]); 
        }
      delay(50);
      matrix.show();




        if (digitalRead(BUTTON_PIN_2) == HIGH) {
         Serial.print("stop 2");
         delay(50);
         break;
        }
 }
}

